<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
                "http://www.w3.org/TR/REC-html40/loose.dtd">
<html>
<head>
  <title>Description of AFQ_SegmentFiberGroups</title>
  <meta name="keywords" content="AFQ_SegmentFiberGroups">
  <meta name="description" content="Categorizes each fiber in a group into one of the 20 tracts defined in">
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
  <meta name="generator" content="m2html v1.5 &copy; 2003-2005 Guillaume Flandin">
  <meta name="robots" content="index, follow">
  <link type="text/css" rel="stylesheet" href="../m2html.css">
</head>
<body>
<a name="_top"></a>
<div><a href="../index.html">Home</a> &gt;  <a href="index.html">functions</a> &gt; AFQ_SegmentFiberGroups.m</div>

<!--<table width="100%"><tr><td align="left"><a href="../index.html"><img alt="<" border="0" src="../left.png">&nbsp;Master index</a></td>
<td align="right"><a href="index.html">Index for functions&nbsp;<img alt=">" border="0" src="../right.png"></a></td></tr></table>-->

<h1>AFQ_SegmentFiberGroups
</h1>

<h2><a name="_name"></a>PURPOSE <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
<div class="box"><strong>Categorizes each fiber in a group into one of the 20 tracts defined in</strong></div>

<h2><a name="_synopsis"></a>SYNOPSIS <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
<div class="box"><strong>function [fg_classified,fg_unclassified,classification,fg] =AFQ_SegmentFiberGroups(dt6File, fg, Atlas,useRoiBasedApproach, useInterhemisphericSplit) </strong></div>

<h2><a name="_description"></a>DESCRIPTION <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
<div class="fragment"><pre class="comment"> Categorizes each fiber in a group into one of the 20 tracts defined in
 the Mori white matter atlas. 

  [fg_classified,fg_unclassified]= AFQ_SegmentFiberGroups(dt6File, fg, ...
      [Atlas='MNI_JHU_tracts_prob.nii.gz'], ...
      [useRoiBasedApproach=true] ...
      [useInterhemisphericSplit=true]);

  Fibers are segmented in two steps. Fibers become candidates for a fiber
  group if the pass through the 2 waypoint ROIs that define the
  tracjectory of the tract. Then each fiber is compared to a fiber
  proability map and high probability fibers are retained in the group.
  The segmentation alogrithm is based on:

  Hua K, Zhang J, Wakana S, Jiang H, Li X, Reich DS, Calabresi PA, Pekar
  JJ, van Zijl PC, Mori S. 2008. Tract probability maps in stereotaxic
  spaces: analyses of white matter anatomy and tract-specific
  quantification. Neuroimage 39(1):336-47.

  Zhang, W., Olivi, A., Hertig, S. J., van Zijl, P., &amp; Mori, S. (2008).
  Automated fiber tracking of human brain white matter using diffusion
  tensor imaging. Neuroimage, 42(2), 771-777.

 Input parameters:
 dt6File                  - Either the dt6 structure or a path to the
                            dt6.mat file
 fg                       - A file with previously tracked elsewhere fibers
                          to be categorized.
 Atlas                    - probabilistic atlas defining probabilities for
                          each voxel to be passed by a fiber within each of
                          atlas fiber groups. We usually use Mori atlas
                          supplied with fsl: MNI_JHU_tracts_prob.nii.gz.
                          This atlas is not symmetric. For a &quot;symmetrified&quot;
                          atlas use 'MNI_JHU_tracts_prob_Symmetric.nii.gz'
                          but we strongly recommend using the original
                          atlas.
 useInterhemisphericSplit - cut fibers crossing between hemispheres with a
                          midsaggital plane below z=-10. This is to get
                          rid of CST fibers that appear to cross at the
                          level of the brainstem
 useRoiBasedApproach      - use the approach describing in Zhang (2008) Neuroimage 42.
                           For each of the 20 Mori Groups 2 critical ROIs
                           are computed by spatially transforming ROIs
                           provided in templates/MNI_JHU_tracts_ROIs. A
                           fiber becomes a candidate to being labeled as a
                           part of a given Mori group if this fiber
                           &quot;passes through&quot; both critical ROIs for that
                           Mori group. Our modification of Zhang (2008)
                           approach: In case a single fiber is a candidate
                           for &gt;1 Mori group, respective cumulative
                           probabilities are computed with probabilistic
                           Mori atlas, then compared.
                           useRoiBasedApproach can take the following
                           values: (1) 'false' (to not use the approach);
                           (2) 'true'(use the approach; the minimal
                           distance from a fiber to ROI to count as &quot;a
                           fiber  is crossing the ROI&quot; minDist=2mm); (3) a
                           scalar value for minDist in mm; (4) a vector
                           with the first value being minDist and the
                           second value being a flag 1/0 for whether ROIs
                           should be recomputed (and overwritten) for this
                           subject (1, by default). This is useful because
                           sometimes if you  are rerunning
                           dtiFindMoriTracts with different parameters,
                           you do not need to recompute ROIs.  E.g., to
                           avoid recomputing  ROIs and use minDist of 4mm
                           one would pass [useRoiBasedApproach=[4 0]];

 Output parameters:
 fg_ classified  - fibers structure containing all fibers assigned to
                   one of Mori Groups. Respective group labeles are stored
                   in fg.subgroups field.
 fg_unclassified - fiber structure containing the rest of the (not Mori) fibers.
 classification  - This variable gives the fiber group names and the group
                   fiber group number for each fiber in the input group
                   fg.  classification is a structure with two fields.
                   classification.names is a cell array where each cell is
                   the name of that fiber group. For example
                   classification.names{3} = 'Corticospinal tract L'.
                   classification.index is a vector that defines which
                   group number each fiber in the origional fiber group
                   was assigned to. For example
                   classification.index(150)=3 means that fg.fibers(150)
                   is part of the corticospinal tract fiber group.  The
                   values in classification may not match the origional
                   fiber group because of pre-processing.  However they
                   will match the output fg which is the origional group
                   with preprocessing.
 fg              - This is the origional pre-segmented fiber group.  It
                   may differ slightly from the input due to preprocessing
                   (eg splitting fibers that cross at the pons, removing 
                   fibers that a too short)
                    
 Example:
    AFQdata = '/home/jyeatman/matlab/svn/vistadata/AFQ';
    dt6File = fullfile(AFQdata, 'subj2', 'dt6.mat');
    fg      = AFQ_SegmentFiberGroups(dt6File);

 See also: dtiSplitInterhemisphericFibers

 (c) Vistalab</pre></div>

<!-- crossreference -->
<h2><a name="_cross"></a>CROSS-REFERENCE INFORMATION <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
This function calls:
<ul style="list-style-image:url(../matlabicon.gif)">
<li><a href="AFQ_WholebrainTractography.html" class="code" title="function fg = AFQ_WholebrainTractography(dt,run_mode,params)">AFQ_WholebrainTractography</a>	Perform whole brain deterministic tractography within a white matter mask</li></ul>
This function is called by:
<ul style="list-style-image:url(../matlabicon.gif)">
<li><a href="AFQ_run.html" class="code" title="function [afq patient_data control_data norms abn abnTracts] = AFQ_run(sub_dirs, sub_group, afq)">AFQ_run</a>	Run AFQ analysis on a set of subjects to generate Tract Profiles of white</li></ul>
<!-- crossreference -->



<h2><a name="_source"></a>SOURCE CODE <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
<div class="fragment"><pre>0001 <a name="_sub0" href="#_subfunctions" class="code">function [fg_classified,fg_unclassified,classification,fg] = </a><span class="keyword">...</span>
0002     AFQ_SegmentFiberGroups(dt6File, fg, Atlas, <span class="keyword">...</span>
0003     useRoiBasedApproach, useInterhemisphericSplit)
0004 <span class="comment">% Categorizes each fiber in a group into one of the 20 tracts defined in</span>
0005 <span class="comment">% the Mori white matter atlas.</span>
0006 <span class="comment">%</span>
0007 <span class="comment">%  [fg_classified,fg_unclassified]= AFQ_SegmentFiberGroups(dt6File, fg, ...</span>
0008 <span class="comment">%      [Atlas='MNI_JHU_tracts_prob.nii.gz'], ...</span>
0009 <span class="comment">%      [useRoiBasedApproach=true] ...</span>
0010 <span class="comment">%      [useInterhemisphericSplit=true]);</span>
0011 <span class="comment">%</span>
0012 <span class="comment">%  Fibers are segmented in two steps. Fibers become candidates for a fiber</span>
0013 <span class="comment">%  group if the pass through the 2 waypoint ROIs that define the</span>
0014 <span class="comment">%  tracjectory of the tract. Then each fiber is compared to a fiber</span>
0015 <span class="comment">%  proability map and high probability fibers are retained in the group.</span>
0016 <span class="comment">%  The segmentation alogrithm is based on:</span>
0017 <span class="comment">%</span>
0018 <span class="comment">%  Hua K, Zhang J, Wakana S, Jiang H, Li X, Reich DS, Calabresi PA, Pekar</span>
0019 <span class="comment">%  JJ, van Zijl PC, Mori S. 2008. Tract probability maps in stereotaxic</span>
0020 <span class="comment">%  spaces: analyses of white matter anatomy and tract-specific</span>
0021 <span class="comment">%  quantification. Neuroimage 39(1):336-47.</span>
0022 <span class="comment">%</span>
0023 <span class="comment">%  Zhang, W., Olivi, A., Hertig, S. J., van Zijl, P., &amp; Mori, S. (2008).</span>
0024 <span class="comment">%  Automated fiber tracking of human brain white matter using diffusion</span>
0025 <span class="comment">%  tensor imaging. Neuroimage, 42(2), 771-777.</span>
0026 <span class="comment">%</span>
0027 <span class="comment">% Input parameters:</span>
0028 <span class="comment">% dt6File                  - Either the dt6 structure or a path to the</span>
0029 <span class="comment">%                            dt6.mat file</span>
0030 <span class="comment">% fg                       - A file with previously tracked elsewhere fibers</span>
0031 <span class="comment">%                          to be categorized.</span>
0032 <span class="comment">% Atlas                    - probabilistic atlas defining probabilities for</span>
0033 <span class="comment">%                          each voxel to be passed by a fiber within each of</span>
0034 <span class="comment">%                          atlas fiber groups. We usually use Mori atlas</span>
0035 <span class="comment">%                          supplied with fsl: MNI_JHU_tracts_prob.nii.gz.</span>
0036 <span class="comment">%                          This atlas is not symmetric. For a &quot;symmetrified&quot;</span>
0037 <span class="comment">%                          atlas use 'MNI_JHU_tracts_prob_Symmetric.nii.gz'</span>
0038 <span class="comment">%                          but we strongly recommend using the original</span>
0039 <span class="comment">%                          atlas.</span>
0040 <span class="comment">% useInterhemisphericSplit - cut fibers crossing between hemispheres with a</span>
0041 <span class="comment">%                          midsaggital plane below z=-10. This is to get</span>
0042 <span class="comment">%                          rid of CST fibers that appear to cross at the</span>
0043 <span class="comment">%                          level of the brainstem</span>
0044 <span class="comment">% useRoiBasedApproach      - use the approach describing in Zhang (2008) Neuroimage 42.</span>
0045 <span class="comment">%                           For each of the 20 Mori Groups 2 critical ROIs</span>
0046 <span class="comment">%                           are computed by spatially transforming ROIs</span>
0047 <span class="comment">%                           provided in templates/MNI_JHU_tracts_ROIs. A</span>
0048 <span class="comment">%                           fiber becomes a candidate to being labeled as a</span>
0049 <span class="comment">%                           part of a given Mori group if this fiber</span>
0050 <span class="comment">%                           &quot;passes through&quot; both critical ROIs for that</span>
0051 <span class="comment">%                           Mori group. Our modification of Zhang (2008)</span>
0052 <span class="comment">%                           approach: In case a single fiber is a candidate</span>
0053 <span class="comment">%                           for &gt;1 Mori group, respective cumulative</span>
0054 <span class="comment">%                           probabilities are computed with probabilistic</span>
0055 <span class="comment">%                           Mori atlas, then compared.</span>
0056 <span class="comment">%                           useRoiBasedApproach can take the following</span>
0057 <span class="comment">%                           values: (1) 'false' (to not use the approach);</span>
0058 <span class="comment">%                           (2) 'true'(use the approach; the minimal</span>
0059 <span class="comment">%                           distance from a fiber to ROI to count as &quot;a</span>
0060 <span class="comment">%                           fiber  is crossing the ROI&quot; minDist=2mm); (3) a</span>
0061 <span class="comment">%                           scalar value for minDist in mm; (4) a vector</span>
0062 <span class="comment">%                           with the first value being minDist and the</span>
0063 <span class="comment">%                           second value being a flag 1/0 for whether ROIs</span>
0064 <span class="comment">%                           should be recomputed (and overwritten) for this</span>
0065 <span class="comment">%                           subject (1, by default). This is useful because</span>
0066 <span class="comment">%                           sometimes if you  are rerunning</span>
0067 <span class="comment">%                           dtiFindMoriTracts with different parameters,</span>
0068 <span class="comment">%                           you do not need to recompute ROIs.  E.g., to</span>
0069 <span class="comment">%                           avoid recomputing  ROIs and use minDist of 4mm</span>
0070 <span class="comment">%                           one would pass [useRoiBasedApproach=[4 0]];</span>
0071 <span class="comment">%</span>
0072 <span class="comment">% Output parameters:</span>
0073 <span class="comment">% fg_ classified  - fibers structure containing all fibers assigned to</span>
0074 <span class="comment">%                   one of Mori Groups. Respective group labeles are stored</span>
0075 <span class="comment">%                   in fg.subgroups field.</span>
0076 <span class="comment">% fg_unclassified - fiber structure containing the rest of the (not Mori) fibers.</span>
0077 <span class="comment">% classification  - This variable gives the fiber group names and the group</span>
0078 <span class="comment">%                   fiber group number for each fiber in the input group</span>
0079 <span class="comment">%                   fg.  classification is a structure with two fields.</span>
0080 <span class="comment">%                   classification.names is a cell array where each cell is</span>
0081 <span class="comment">%                   the name of that fiber group. For example</span>
0082 <span class="comment">%                   classification.names{3} = 'Corticospinal tract L'.</span>
0083 <span class="comment">%                   classification.index is a vector that defines which</span>
0084 <span class="comment">%                   group number each fiber in the origional fiber group</span>
0085 <span class="comment">%                   was assigned to. For example</span>
0086 <span class="comment">%                   classification.index(150)=3 means that fg.fibers(150)</span>
0087 <span class="comment">%                   is part of the corticospinal tract fiber group.  The</span>
0088 <span class="comment">%                   values in classification may not match the origional</span>
0089 <span class="comment">%                   fiber group because of pre-processing.  However they</span>
0090 <span class="comment">%                   will match the output fg which is the origional group</span>
0091 <span class="comment">%                   with preprocessing.</span>
0092 <span class="comment">% fg              - This is the origional pre-segmented fiber group.  It</span>
0093 <span class="comment">%                   may differ slightly from the input due to preprocessing</span>
0094 <span class="comment">%                   (eg splitting fibers that cross at the pons, removing</span>
0095 <span class="comment">%                   fibers that a too short)</span>
0096 <span class="comment">%</span>
0097 <span class="comment">% Example:</span>
0098 <span class="comment">%    AFQdata = '/home/jyeatman/matlab/svn/vistadata/AFQ';</span>
0099 <span class="comment">%    dt6File = fullfile(AFQdata, 'subj2', 'dt6.mat');</span>
0100 <span class="comment">%    fg      = AFQ_SegmentFiberGroups(dt6File);</span>
0101 <span class="comment">%</span>
0102 <span class="comment">% See also: dtiSplitInterhemisphericFibers</span>
0103 <span class="comment">%</span>
0104 <span class="comment">% (c) Vistalab</span>
0105 
0106 <span class="comment">%% Check arguments</span>
0107 
0108 <span class="keyword">if</span> ~exist(<span class="string">'useInterhemisphericSplit'</span>, <span class="string">'var'</span>) || isempty(useInterhemisphericSplit)
0109     useInterhemisphericSplit=true;
0110 <span class="keyword">end</span>
0111 
0112 <span class="keyword">if</span> ~exist(<span class="string">'useRoiBasedApproach'</span>, <span class="string">'var'</span>)|| isempty(useRoiBasedApproach)
0113     useRoiBasedApproach=true;
0114 <span class="keyword">end</span>
0115 <span class="comment">% Decide on the recomputeROI condition</span>
0116 <span class="keyword">if</span> useRoiBasedApproach==false,         recomputeROIs = false;
0117 <span class="keyword">elseif</span> length(useRoiBasedApproach)&lt;2,  recomputeROIs = 1;
0118 <span class="keyword">else</span>                                   recomputeROIs = useRoiBasedApproach(2);
0119 <span class="keyword">end</span>
0120 <span class="keyword">if</span> recomputeROIs
0121     display(<span class="string">'You chose to recompute ROIs'</span>);
0122 <span class="keyword">end</span>
0123 <span class="comment">%E.g., to avoid recomputing  ROIs and use minDist of 4mm one would pass [useRoiBasedApproach=[4 0]];</span>
0124 <span class="keyword">if</span> isnumeric(useRoiBasedApproach)
0125     minDist=useRoiBasedApproach(1);
0126     useRoiBasedApproach=<span class="string">'true'</span>;
0127 <span class="keyword">else</span>
0128     minDist=2; <span class="comment">%defualt is .89;</span>
0129 <span class="keyword">end</span>
0130 display([<span class="string">'Fibers that get as close to the ROIs as '</span> num2str(minDist) <span class="string">'mm will become candidates for the Mori Groups'</span>]);
0131 <span class="comment">% This is left as an option in case an updated atlas is released</span>
0132 <span class="keyword">if</span>(~exist(<span class="string">'Atlas'</span>,<span class="string">'var'</span>) || isempty(Atlas))
0133     <span class="comment">%Default scenario: use original Mori Atlas</span>
0134     Atlas=<span class="string">'MNI_JHU_tracts_prob.nii.gz'</span>;
0135 <span class="keyword">end</span>
0136 
0137 <span class="comment">%% Read the data</span>
0138 <span class="comment">% Load the dt6 file</span>
0139 <span class="keyword">if</span> ischar(dt6File)
0140     dt = dtiLoadDt6(dt6File);
0141     baseDir = fileparts(dt6File); 
0142 <span class="keyword">else</span>
0143     dt = dt6File;
0144     baseDir = fileparts(dt.dataFile);
0145     dt6File = dt.dataFile;
0146 <span class="keyword">end</span>
0147 <span class="comment">% Track wholebrain fiber group if one was not passed in</span>
0148 <span class="keyword">if</span> ~exist(<span class="string">'fg'</span>,<span class="string">'var'</span>) || isempty(fg)
0149     fg = <a href="AFQ_WholebrainTractography.html" class="code" title="function fg = AFQ_WholebrainTractography(dt,run_mode,params)">AFQ_WholebrainTractography</a>(dt);
0150 <span class="keyword">end</span>
0151 <span class="comment">% Load fiber group - Can be filename or the data</span>
0152 <span class="keyword">if</span> ischar(fg), fg = dtiLoadFiberGroup(fg); <span class="keyword">end</span>
0153 <span class="comment">% Create an array that will denote which fiber group each of these fibers</span>
0154 <span class="comment">% was assigned to.</span>
0155 fiberIndex = zeros(length(fg.fibers),1);
0156 <span class="comment">% Set the directory where templates can be found</span>
0157 tdir = fullfile(fileparts(which(<span class="string">'mrDiffusion.m'</span>)), <span class="string">'templates'</span>);
0158 <span class="comment">% Initialize spm defualts for normalization</span>
0159 spm_defaults; <span class="keyword">global</span> defaults; params = defaults.normalise.estimate;
0160 <span class="comment">% spm_get_defaults - For SPM8</span>
0161 
0162 <span class="comment">%% Spatially normalize diffusion data with the MNI (ICBM) template</span>
0163 template = fullfile(tdir,<span class="string">'MNI_JHU_T2.nii.gz'</span>);
0164 <span class="comment">% Rescale image valueds to get better gary/white/CSF contrast</span>
0165 alignIm = mrAnatHistogramClip(double(dt.b0),0.3,0.99);
0166 <span class="comment">% Compute normalization</span>
0167 [sn, Vtemplate, invDef] = mrAnatComputeSpmSpatialNorm(alignIm, dt.xformToAcpc, template, params);
0168 <span class="comment">% check the normalization</span>
0169 mm = diag(chol(Vtemplate.mat(1:3,1:3)'*Vtemplate.mat(1:3,1:3)))';
0170 bb = mrAnatXformCoords(Vtemplate.mat,[1 1 1; Vtemplate.dim]);
0171 alignIm_sn = mrAnatResliceSpm(alignIm, sn, bb, [2 2 2], [1 1 1 0 0 0], 0);
0172 tIm = mrAnatResliceSpm(double(Vtemplate.dat), inv(Vtemplate.mat), bb, [2 2 2], [1 1 1 0 0 0], 0);
0173 im(:,:,:,1) = uint8(tIm);
0174 im(:,:,:,2) = uint8(round(clip(alignIm_sn)*255));
0175 im(:,:,:,3) = im(:,:,:,2);
0176 <span class="comment">% Save an image of the spatially normalized data showing the quality of the</span>
0177 <span class="comment">% alignment</span>
0178 imwrite(makeMontage(im),fullfile(baseDir, <span class="string">'SpatialNormalization.png'</span>));
0179 
0180 <span class="comment">%% Compute fiber group probabilities using the atlas proceedure of Hua.2008</span>
0181 <span class="comment">% Load the Mori atlas maps these are saved in nifti images</span>
0182 moriTracts = readFileNifti(fullfile(tdir, Atlas));
0183 <span class="comment">% 15 is a subregion of 19 and 16 a subregion of 20. To better separate them,</span>
0184 <span class="comment">% we subtract 19 from 15 and 20 from 16.</span>
0185 moriTracts.data(:,:,:,15) = moriTracts.data(:,:,:,15)-moriTracts.data(:,:,:,19);
0186 moriTracts.data(:,:,:,16) = moriTracts.data(:,:,:,16)-moriTracts.data(:,:,:,20);
0187 <span class="comment">% Load the fiber group labels</span>
0188 <span class="comment">%labels = readTab(fullfile(tdir,'MNI_JHU_tracts_prob.txt'),',',false);</span>
0189 <span class="comment">%labels = labels(1:20,2);</span>
0190 labels = {<span class="string">'Left Thalamic Radiation'</span>,<span class="string">'Right Thalamic Radiation'</span>,<span class="string">'Left Corticospinal'</span>,<span class="string">'Right Corticospinal'</span>, <span class="string">'Left Cingulum Cingulate'</span>, <span class="string">'Right Cingulum Cingulate'</span><span class="keyword">...</span>
0191     <span class="string">'Left Cingulum Hippocampus'</span>,<span class="string">'Right Cingulum Hippocampus'</span>, <span class="string">'Callosum Forceps Major'</span>, <span class="string">'Callosum Forceps Minor'</span><span class="keyword">...</span>
0192     <span class="string">'Left IFOF'</span>,<span class="string">'Right IFOF'</span>,<span class="string">'Left ILF'</span>,<span class="string">'Right ILF'</span>,<span class="string">'Left SLF'</span>,<span class="string">'Right SLF'</span>,<span class="string">'Left Uncinate'</span>,<span class="string">'Right Uncinate'</span>,<span class="string">'Left Arcuate'</span>,<span class="string">'Right Arcuate'</span>};
0193 
0194 <span class="comment">% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % %</span>
0195 <span class="comment">% If you wanted to inverse-normalize the maps to this subject's brain:</span>
0196 <span class="comment">% invDef.outMat = moriTracts.qto_ijk;</span>
0197 <span class="comment">% bb = mrAnatXformCoords(dt.xformToAcpc,[1 1 1; size(dt.b0)]);</span>
0198 <span class="comment">% tprob = mrAnatResliceSpm(tprob, invDef, bb, dt.mmPerVoxel, [1 1 1 0 0 0]);</span>
0199 <span class="comment">% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % %</span>
0200 
0201 <span class="comment">% Cut the fibers below the acpc plane, to disentangle CST &amp; ATL crossing</span>
0202 <span class="comment">% at the level of the pons</span>
0203 <span class="keyword">if</span> useInterhemisphericSplit
0204     fgname  = fg.name;
0205     fg      = dtiSplitInterhemisphericFibers(fg, dt, -10);
0206     fg.name = fgname;
0207 <span class="keyword">end</span>
0208 <span class="comment">% Throw out fibers that are too short to span between two ROIs</span>
0209 <span class="keyword">if</span> sum(cellfun(@length, fg.fibers)&lt;5)~=0
0210     <span class="keyword">if</span> isfield(fg, <span class="string">'subgroup'</span>)&amp;&amp;~isempty(fg.subgroup)
0211         fg.subgroup(cellfun(@length, fg.fibers)&lt;5)=[];
0212     <span class="keyword">end</span>
0213     <span class="keyword">if</span> isfield(fg, <span class="string">'seeds'</span>)&amp;&amp;~isempty(fg.seeds)
0214         fg.seeds(cellfun(@length, fg.fibers)&lt;5, :)=[];
0215     <span class="keyword">end</span>
0216     fg.fibers(cellfun(@length, fg.fibers)&lt;5)=[];
0217 <span class="keyword">end</span>
0218 
0219 <span class="comment">% Warp the fibers to the MNI standard space so they can be compared to the</span>
0220 <span class="comment">% template</span>
0221 fg_sn = dtiXformFiberCoords(fg, invDef);
0222 
0223 <span class="comment">% moriTracts.data is a an XxYxZx20 array contianing the 20 Mori probability</span>
0224 <span class="comment">% atlases (range is 0-100 where 100 represents p(1)).</span>
0225 sz = size(moriTracts.data);
0226 <span class="comment">% fg_sn fiber coords are in MNI space- now convert them to atlas space by</span>
0227 <span class="comment">% applying the affine xform from the atlas NIFTI header. Since the atlas is</span>
0228 <span class="comment">% already in MNI space, this transform will just account for any</span>
0229 <span class="comment">% translation and scale differences between the atlas maps and the MNI</span>
0230 <span class="comment">% template used to compute our sn.</span>
0231 fgCoords = mrAnatXformCoords(moriTracts.qto_ijk, horzcat(fg_sn.fibers{:}));
0232 clear fg_sn;   <span class="comment">% what we need from fg_sn is now stored in fgCoords</span>
0233 fgLen = cellfun(<span class="string">'size'</span>,fg.fibers,2);
0234 
0235 <span class="comment">% Now loop over the 20 atlases and get the atlas probability score for each</span>
0236 <span class="comment">% fiber point. We collapse the scores across all points in a fiber by taking</span>
0237 <span class="comment">% the mean. Below, we will use these 20 mean scores to categorize the fibers.</span>
0238 <span class="comment">% TO DO: consider doing something more sophisticated than taking the mean.</span>
0239 fp = zeros(sz(4),numel(fg.fibers));
0240 <span class="keyword">for</span>(ii=1:sz(4))
0241     <span class="comment">% Get the Mori atlas score for each point in the fibers using</span>
0242     <span class="comment">% trilinear interpolation.</span>
0243     p = myCinterp3(double(moriTracts.data(:,:,:,ii))/100, sz([1,2]), sz(3), fgCoords(:,[2,1,3]));
0244     <span class="comment">% The previous line interpolated one giant array with all fiber points</span>
0245     <span class="comment">% concatenated. The next loop will separate the coordinates back into</span>
0246     <span class="comment">% fibers and take the mean score for the points within each fiber.</span>
0247     fiberCoord = 1;
0248     <span class="keyword">for</span>(jj=1:numel(fg.fibers))
0249         fp(ii,jj) = nanmean(p([fiberCoord:fiberCoord+fgLen(jj)-1]));
0250         fiberCoord = fiberCoord+fgLen(jj);
0251     <span class="keyword">end</span>
0252 <span class="keyword">end</span>
0253 clear p fgCoords;
0254 
0255 <span class="comment">%% Find fibers that pass through both waypoint ROIs eg. Wakana 2007</span>
0256 <span class="comment">%Warp Mori ROIs to individual space; collect candidates for each fiber</span>
0257 <span class="comment">%group based on protocol of 2 or &gt; ROIs a fiber should travel through. The</span>
0258 <span class="comment">%following ROIs are saved within</span>
0259 <span class="comment">%trunk/mrDiffusion/templates/MNI_JHU_tracts_ROIs folder and are created</span>
0260 <span class="comment">%using MNI template as described in Wakana et al.(2007) Neuroimage 36 with</span>
0261 <span class="comment">%a single modification: For SLFt Roi2, they recommend drawing the ROI at</span>
0262 <span class="comment">%the AC level, whereas we use a slice just inferior of CC splenium. The</span>
0263 <span class="comment">%reason for this modification is that Wakana et al. ACPC aligned images</span>
0264 <span class="comment">%appear different from MNI images (the latter we use for defininng ROIs).</span>
0265 <span class="comment">%If defining SLFt-Roi2 on a slice actually at the AC level (althought</span>
0266 <span class="comment">%highly consistently across human raters), many SLFt fibers were not</span>
0267 <span class="comment">%correctly labeled as they extend laterally into temporal lobe just above</span>
0268 <span class="comment">%the aforementioned ROI plane.</span>
0269 <span class="keyword">if</span> useRoiBasedApproach 
0270     <span class="comment">% A 20x2 cell array containing the names of both waypoint ROIs for each</span>
0271     <span class="comment">% of 20 fiber groups</span>
0272     moriRois={<span class="string">'ATR_roi1_L.nii.gz'</span>,  <span class="string">'ATR_roi2_L.nii.gz'</span>; <span class="string">'ATR_roi1_R.nii.gz'</span>, <span class="string">'ATR_roi2_R.nii.gz'</span>; <span class="keyword">...</span>
0273         <span class="string">'CST_roi1_L.nii.gz'</span>, <span class="string">'CST_roi2_L.nii.gz'</span>; <span class="string">'CST_roi1_R.nii.gz'</span>,  <span class="string">'CST_roi2_R.nii.gz'</span>; <span class="keyword">...</span>
0274         <span class="string">'CGC_roi1_L.nii.gz'</span>, <span class="string">'CGC_roi2_L.nii.gz'</span>; <span class="string">'CGC_roi1_R.nii.gz'</span>, <span class="string">'CGC_roi2_R.nii.gz'</span>; <span class="keyword">...</span>
0275         <span class="string">'HCC_roi1_L.nii.gz'</span>, <span class="string">'HCC_roi2_L.nii.gz'</span>; <span class="string">'HCC_roi1_R.nii.gz'</span>, <span class="string">'HCC_roi2_R.nii.gz'</span>;<span class="keyword">...</span>
0276         <span class="string">'FP_R.nii.gz'</span>, <span class="string">'FP_L.nii.gz'</span>; <span class="keyword">...</span>
0277         <span class="string">'FA_L.nii.gz'</span>, <span class="string">'FA_R.nii.gz'</span>; <span class="keyword">...</span>
0278         <span class="string">'IFO_roi1_L.nii.gz'</span>, <span class="string">'IFO_roi2_L.nii.gz'</span>; <span class="string">'IFO_roi2_R.nii.gz'</span>, <span class="string">'IFO_roi1_R.nii.gz'</span>; <span class="keyword">...</span>
0279         <span class="string">'ILF_roi1_L.nii.gz'</span>, <span class="string">'ILF_roi2_L.nii.gz'</span>; <span class="string">'ILF_roi1_R.nii.gz'</span>, <span class="string">'ILF_roi2_R.nii.gz'</span>; <span class="keyword">...</span>
0280         <span class="string">'SLF_roi1_L.nii.gz'</span>, <span class="string">'SLF_roi2_L.nii.gz'</span>; <span class="string">'SLF_roi1_R.nii.gz'</span>, <span class="string">'SLF_roi2_R.nii.gz'</span>; <span class="keyword">...</span>
0281         <span class="string">'UNC_roi1_L.nii.gz'</span>, <span class="string">'UNC_roi2_L.nii.gz'</span>; <span class="string">'UNC_roi1_R.nii.gz'</span>, <span class="string">'UNC_roi2_R.nii.gz'</span>; <span class="keyword">...</span>
0282         <span class="string">'SLF_roi1_L.nii.gz'</span>, <span class="string">'SLFt_roi2_L.nii.gz'</span>; <span class="string">'SLF_roi1_R.nii.gz'</span>, <span class="string">'SLFt_roi2_R.nii.gz'</span>};
0283     <span class="comment">% Make an ROI for the mid saggital plane</span>
0284     midSaggitalRoi= dtiRoiMakePlane([0, dt.bb(1, 2), dt.bb(1, 3); 0 , dt.bb(2, 2) , dt.bb(2, 3)], <span class="string">'midsaggital'</span>, <span class="string">'g'</span>);
0285     keep1=zeros(length(fg.fibers), size(moriRois, 1)); keep2=zeros(length(fg.fibers), size(moriRois, 1));
0286     <span class="comment">% Find fibers that cross mid saggital plane</span>
0287     [fgOut, contentiousFibers, InterHemisphericFibers] = dtiIntersectFibersWithRoi([], <span class="string">'not'</span>, [], midSaggitalRoi, fg); 
0288     <span class="comment">%NOTICE: ~keep3 (not &quot;keep3&quot;) will mark fibers that DO NOT cross</span>
0289     <span class="comment">%midSaggitalRoi.</span>
0290     keep3=repmat(InterHemisphericFibers, [1 size(moriRois, 1)]);
0291     fgCopy=fg; fgCopy.subgroup=[];
0292     <span class="keyword">for</span> roiID=1:size(moriRois, 1)
0293         <span class="comment">% Load the nifit image containing ROI-1 in MNI space</span>
0294         ROI_img_file=fullfile(tdir, <span class="string">'MNI_JHU_tracts_ROIs'</span>,  [moriRois{roiID, 1}]);
0295         <span class="comment">% Transform ROI-1 to an individuals native space</span>
0296         <span class="keyword">if</span> recomputeROIs
0297             [RoiFileName, invDef, roi]=dtiCreateRoiFromMniNifti(dt6File, ROI_img_file, invDef, true);
0298         <span class="keyword">else</span>
0299             RoiFileName=fullfile(fileparts(dt6File), <span class="string">'ROIs'</span>,  [prefix(prefix(ROI_img_file, <span class="string">'short'</span>), <span class="string">'short'</span>) <span class="string">'.mat'</span>]);
0300             load(RoiFileName);  
0301         <span class="keyword">end</span>
0302         <span class="comment">% Find fibers that intersect the ROI</span>
0303         [fgOut,contentiousFibers, keep1(:, roiID)] = dtiIntersectFibersWithRoi([], <span class="string">'and'</span>, minDist, roi, fg);
0304         keepID1=find(keep1(:, roiID));
0305         <span class="comment">% Load the nifit image containing ROI-2 in MNI space</span>
0306         ROI_img_file=fullfile(tdir, <span class="string">'MNI_JHU_tracts_ROIs'</span>,  [moriRois{roiID, 2}]);
0307         <span class="comment">% Transform ROI-2 to an individuals native space</span>
0308         <span class="keyword">if</span> recomputeROIs
0309             [RoiFileName, invDef, roi]=dtiCreateRoiFromMniNifti(dt6File, ROI_img_file, invDef, true);
0310         <span class="keyword">else</span>
0311             RoiFileName=fullfile(fileparts(dt6File), <span class="string">'ROIs'</span>,  [prefix(prefix(ROI_img_file, <span class="string">'short'</span>), <span class="string">'short'</span>) <span class="string">'.mat'</span>]);
0312             load(RoiFileName);
0313         <span class="keyword">end</span>
0314         <span class="comment">%To speed up the function, we intersect with the second ROI not all the</span>
0315         <span class="comment">%fibers, but only those that passed first ROI.</span>
0316         fgCopy.fibers=fg.fibers(keepID1(keepID1&gt;0));
0317         [a,b, keep2given1] = dtiIntersectFibersWithRoi([], <span class="string">'and'</span>, minDist, roi, fgCopy);
0318         keep2(keepID1(keep2given1), roiID)=true; 
0319     <span class="keyword">end</span>
0320     clear fgOut contentiousFibers keepID
0321     <span class="comment">%Note: forceps major and minor should NOT have interhemipsheric fibers</span>
0322     <span class="comment">% excluded</span>
0323     keep3(:, 9:10)=keep3(:, 9:10).*0;
0324     <span class="comment">% fp is the variable containing each fibers score for matching the</span>
0325     <span class="comment">% atlas. We will set each fibers score to 0 if it does not pass through</span>
0326     <span class="comment">% the necessary ROIs</span>
0327     fp(~(keep1'&amp;keep2'&amp;~keep3'))=0;
0328     <span class="comment">%Also note: Tracts that cross through slf_t rois should be automatically</span>
0329     <span class="comment">%classified as slf_t, without considering their probs.</span>
0330     fp(19, (keep1(:, 19)'&amp;keep2(:, 19)'&amp;~keep3(:, 19)'))=max(fp(:));
0331     fp(20, (keep1(:, 20)'&amp;keep2(:, 20)'&amp;~keep3(:, 20)'))=max(fp(:));
0332 <span class="keyword">end</span>
0333 
0334 <span class="comment">%% Eliminate fibers that don't match any of the atlases very well</span>
0335 <span class="comment">% We have a set of atlas scores for each each fiber. To categorize the</span>
0336 <span class="comment">% fibers, we will find the atlas with the highest score (using 'sort').</span>
0337 [atlasScore,atlasInd] = sort(fp,1,<span class="string">'descend'</span>);
0338 <span class="comment">% Eliminate fibers that don't match any of the atlases very well:</span>
0339 unclassified=atlasScore(1,:)==0;
0340 goodEnough = atlasScore(1,:)~=0;
0341 curAtlasFibers = cell(1,sz(4));
0342 <span class="keyword">for</span> ii=1:sz(4)
0343     curAtlasFibers{ii} = find(atlasInd(1,:)==ii &amp; goodEnough);
0344 <span class="keyword">end</span>
0345 
0346 <span class="comment">% We now have a cell array (curAtlasFibers) that contains 20 arrays, each</span>
0347 <span class="comment">% listing the fiber indices for the corresponding atlas group. E.g.,</span>
0348 <span class="comment">% curAtlasFibers{3} is a list of indices into fg.fibers that specify the</span>
0349 <span class="comment">% fibers belonging to group 3.</span>
0350 
0351 <span class="comment">%Create a FG for unclassified fibers</span>
0352 fg_unclassified=fg;
0353 fg_unclassified.name=[fg.name <span class="string">' not Mori Groups'</span>];
0354 fg_unclassified.fibers = fg.fibers(unclassified); <span class="comment">%prepare fg output</span>
0355 <span class="keyword">if</span> ~isempty(fg.seeds)
0356     fg_unclassified.seeds = fg.seeds(unclassified);
0357 <span class="keyword">end</span>
0358 fg_unclassified.subgroup=zeros(size(fg.fibers(unclassified)))'+(1+sz(4));
0359 fg_unclassified.subgroupNames(1)=struct(<span class="string">'subgroupIndex'</span>, 1+sz(4), <span class="string">'subgroupName'</span>, <span class="string">'NotMori'</span>);
0360 
0361 <span class="comment">% Create a fiber group for classified fibers</span>
0362 fg_classified = fg;
0363 <span class="comment">% Modify fg.fibers to discard the fibers that didn't make it into any of</span>
0364 <span class="comment">% the atlas groups:</span>
0365 fg_classified.name=[fg.name <span class="string">' Mori Groups'</span>];
0366 fg_classified.fibers = fg.fibers([curAtlasFibers{:}]);
0367 <span class="keyword">if</span> ~isempty(fg.seeds)
0368     fg_classified.seeds = fg.seeds([curAtlasFibers{:}],:);
0369 <span class="keyword">end</span>
0370 
0371 <span class="comment">% We changed the size of fg_classified.fibers by discarding the</span>
0372 <span class="comment">% uncategorized fibers, so we need to create a new array to categorize the</span>
0373 <span class="comment">% fibers. This time we make an array with one entry corresponding to each</span>
0374 <span class="comment">% fiber, with integer values indicating to which atlas group the</span>
0375 <span class="comment">% corresponding fiber belongs.</span>
0376 fg_classified.subgroup = zeros(1,numel(fg_classified.fibers));
0377 curInd = 1;
0378 <span class="keyword">for</span>(ii=1:numel(curAtlasFibers))
0379     fg_classified.subgroup(curInd:curInd+numel(curAtlasFibers{ii})-1) = ii;
0380     <span class="comment">%fghandle.subgroup(curInd:curInd+numel(curAtlasFibers{ii})-1) = ii;</span>
0381     curInd = curInd+numel(curAtlasFibers{ii});
0382     <span class="comment">%Save labels for the fiber subgroups within the file</span>
0383     fg_classified.subgroupNames(ii)=struct(<span class="string">'subgroupIndex'</span>, ii, <span class="string">'subgroupName'</span>, labels(ii));
0384     <span class="comment">%fghandle.subgroupNames(ii)=struct('subgroupIndex', ii, 'subgroupName', labels(ii));</span>
0385 <span class="keyword">end</span>
0386 
0387 <span class="comment">% Create a structure denoting the fiber group number that each fiber in</span>
0388 <span class="comment">% the origional wholebrain group was assigned to</span>
0389 <span class="keyword">for</span> ii = 1 : length(curAtlasFibers)
0390     fiberIndex(curAtlasFibers{ii}) = ii;
0391     names{ii} = fg_classified.subgroupNames(ii).subgroupName;
0392 <span class="keyword">end</span>
0393 
0394 <span class="comment">% Create a structure with fiber indices and group names.</span>
0395 classification.index = fiberIndex;
0396 classification.names = names;
0397 
0398 <span class="keyword">return</span>;
0399 
0400 
0401 
0402 
0403 
0404</pre></div>
<hr><address>Generated on Wed 14-Nov-2012 17:12:08 by <strong><a href="http://www.artefact.tk/software/matlab/m2html/" title="Matlab Documentation in HTML">m2html</a></strong> &copy; 2005</address>
</body>
</html>